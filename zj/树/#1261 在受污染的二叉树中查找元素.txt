给出一个满足下述规则的二叉树：

root.val == 0
如果 treeNode.val == x 且 treeNode.left != null，那么 treeNode.left.val == 2 * x + 1
如果 treeNode.val == x 且 treeNode.right != null，那么 treeNode.right.val == 2 * x + 2
现在这个二叉树受到「污染」，所有的 treeNode.val 都变成了 -1。

请你先还原二叉树，然后实现 FindElements 类：

FindElements(TreeNode* root) 用受污染的二叉树初始化对象，你需要先把它还原。
bool find(int target) 判断目标值 target 是否存在于还原后的二叉树中并返回结果。
 

示例 1：



输入：
["FindElements","find","find"]
[[[-1,null,-1]],[1],[2]]
输出：
[null,false,true]
解释：
FindElements findElements = new FindElements([-1,null,-1]); 
findElements.find(1); // return False 
findElements.find(2); // return True 
示例 2：



输入：
["FindElements","find","find","find"]
[[[-1,-1,-1,-1,-1]],[1],[3],[5]]
输出：
[null,true,true,false]
解释：
FindElements findElements = new FindElements([-1,-1,-1,-1,-1]);
findElements.find(1); // return True
findElements.find(3); // return True
findElements.find(5); // return False
示例 3：



输入：
["FindElements","find","find","find","find"]
[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]
输出：
[null,true,false,false,true]
解释：
FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);
findElements.find(2); // return True
findElements.find(3); // return False
findElements.find(4); // return False
findElements.find(5); // return True
 

提示：

TreeNode.val == -1
二叉树的高度不超过 20
节点的总数在 [1, 10^4] 之间
调用 find() 的总次数在 [1, 10^4] 之间
0 <= target <= 10^6




//  深度优先遍历的同时把节点值保存进hashset
// class FindElements {
//     private BitSet ans = new BitSet(100000);
//     public FindElements(TreeNode root) {
//         dfs(root, 0);
//     }

//     private void dfs(TreeNode node, int val) {
//         if (node == null) return;
//         node.val = val;
//         ans.set(node.val, true);
//         dfs(node.left, val*2 + 1);
//         dfs(node.right, val*2 + 2);
//     }
    
//     public boolean find(int target) {
//         return ans.get(target);
//     }
// }

// 详见题解https://leetcode-cn.com/problems/find-elements-in-a-contaminated-binary-tree/solution/bu-yong-setde-findfang-fa-by-cyanflxy/
// 假定树为完全二叉树，如果所有值加1则为
//             1
//         2       3
//      4    5   6   7
//    8  9 10 11 ...

//                 1
//         10              11
//     100     101    110      111
// 1000  1001  ...

// 从前缀中我们可以找到规律，往左为0 往右为1

class FindElements {
    private TreeNode root;
    public FindElements(TreeNode root) {
        this.root = root;
        dfs(root, 0);
    }

    private void dfs(TreeNode node, int val) {
        if (node == null) return;
        node.val = val;
        dfs(node.left, val*2 + 1);
        dfs(node.right, val*2 + 2);
    }
    
    public boolean find(int target) {
        target++;
        // 第一位一定为1， 从次高位开始计算。
        int bit = Integer.highestOneBit(target) >> 1;
        TreeNode node = root;
        while (bit != 0 && node != null) {
            if ((target & bit) == 0) node = node.left;
            else node = node.right;
            bit >>= 1;
        }
        return node != null;
    }
}