给你一个正整数数组 arr，考虑所有满足以下条件的二叉树：

每个节点都有 0 个或是 2 个子节点。
数组 arr 中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。）
每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。
在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。

 

示例：

输入：arr = [6,2,4]
输出：32
解释：
有两种可能的树，第一种的非叶节点的总和为 36，第二种非叶节点的总和为 32。

    24            24
   /  \          /  \
  12   4        6    8
 /  \               / \
6    2             2   4
 

提示：

2 <= arr.length <= 40
1 <= arr[i] <= 15
答案保证是一个 32 位带符号整数，即小于 2^31。



// 具体题解见 https://leetcode-cn.com/problems/minimum-cost-tree-from-leaf-values/solution/xiang-xi-jie-shi-dong-tai-gui-hua-dan-diao-zhan-ji/
// 题目要求节点只有0个或者2个子节点，所以树中非叶子节点数量和树的形状无关
// 思路：维护一个单调栈
// 这里举个例子[1,3,2,4]和[1,4,2,3]，当我们要往栈中传入最后一个节点(也就是4 / 3，此时栈中具体内容为[3,2] <- 4 / [4,2] <- 3,前面的构建步骤在此忽略)时，节点2需要考虑和哪一个节点(栈中的值可以理解为叶子节点或者代表某棵子树的最大叶子节点)结合构建父节点。[1，3，2，4]中肯定是2和3构建父节点，父节点的最大叶子节点为3，后续3再和4构建父父节点。[1,4,2,3]中则同样是2，3构建父节点，父节点的最大叶子节点为3，后续3再和4构建父父节点。而无论选择哪个节点进行构建，栈顶都会弹出来，新节点继续和新栈顶进行比较，直到比栈顶小，然后压入栈成为栈顶。
// 数组遍历完成后，如果栈中节点数量＞1(实际代码中为2，用于栈中只有一个节点的情况)，这些节点从栈底到栈顶递减，则依次构建父节点然后弹出，因为他们别无选择，只能和右边相对较小的节点构建父节点。
// 所以我们的单调栈维护逻辑就是如果即将压入栈的节点值大于栈顶，则栈顶必须和左右中较小的值构建父节点，因为数组是中序遍历的结果，它也只能和这两个节点构建父节点，不然中序遍历就不可能是数组中的情况。
class Solution {
    public int mctFromLeafValues(int[] arr) {
		Stack<Integer> stack = new Stack();
        stack.push(Integer.MAX_VALUE);
        int ans = 0;
        for (int n : arr) {
            while (stack.peek() < n) ans += stack.pop() * Math.min(stack.peek(), n);
            stack.push(n);
        }
        while (stack.size() > 2) ans += stack.pop() * stack.peek();
        return ans;
    }
}