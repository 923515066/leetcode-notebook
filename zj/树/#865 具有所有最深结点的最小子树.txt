给定一个根为?root?的二叉树，每个结点的深度是它到根的最短距离。

如果一个结点在整个树的任意结点之间具有最大的深度，则该结点是最深的。

一个结点的子树是该结点加上它的所有后代的集合。

返回能满足“以该结点为根的子树中包含所有最深的结点”这一条件的具有最大深度的结点。

?

示例：

输入：[3,5,1,6,2,0,8,null,null,7,4]
输出：[2,7,4]
解释：

我们返回值为 2 的结点，在图中用黄色标记。
在图中用蓝色标记的是树的最深的结点。
输入 "[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]" 是对给定的树的序列化表述。
输出 "[2, 7, 4]" 是对根结点的值为 2 的子树的序列化表述。
输入和输出都具有 TreeNode 类型。
?

提示：

树中结点的数量介于?1 和?500 之间。
每个结点的值都是独一无二的。



// 第一次遍历计算树的高度
// 第二次遍历返回包含所有最深节点的子树
// 当前节点子树不包含最深节点则返回Null
// 如果当前节点左子树 右子树有一颗包含(递归返回不为Null)则返回递归调用返回的节点  
// 如果同时包含则返回当前节点
class Solution {
    private int treeDepth = 0;
    public TreeNode subtreeWithAllDeepest(TreeNode root) {
		treeDepth = maxDepth(root);
        TreeNode returnNode = subtreeWithAllDeepestCore(root, 1);
        return returnNode;
    }

    public int maxDepth(TreeNode root) {
		if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) +1;
    }

    public TreeNode subtreeWithAllDeepestCore(TreeNode root, int depth) {
        if (root == null) return null;
		TreeNode left = subtreeWithAllDeepestCore(root.left, depth+1);
        TreeNode right = subtreeWithAllDeepestCore(root.right, depth+1);
        if (left != null || right != null) {
            if (left != null && right != null) return root;
            else if(left != null) return left;
            else return right;
        }
        if (depth == treeDepth) return root;
        return null;
    }
}

// 官方题解2 
// 只遍历一遍  需要定义递归函数返回的对象(包括返回节点和高度)
