给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。

示例 1: 

输入: [5,7]
输出: 4
示例 2:

输入: [0,1]
输出: 0



// 首先，按位与操作时，只要该位出现过0，则这一位的最终结果必然是0
// 尝试不对所有数进行与操作求得结果，举个例子
// 1的二进制：00000001
// 5的二进制：00000101
// 也就是说范围[1,5]的公共二进制前缀是00000***,所以最终结果就是公共二进制前缀 加上 其余位补零
// 这里官方题解没有给出具体为什么结果是 公共二进制前缀 加上 其余位补零
// 我们粗略的证明所有补零的位上 都出现过0：
// 补零的最高位不用说，因为就是不同(同时出现了0 1)才没有算进前缀里
// 其余位则在数字不断递增直到补零最高位第一次出现差异(也就是为1)时 都为0 证明完毕
class Solution {
    public int rangeBitwiseAnd(int m, int n) {
        int shift = 0;
        while(m < n) {
            m >>= 1;
            n >>= 1;
            shift++;
        }
        return m << shift;
    }
}