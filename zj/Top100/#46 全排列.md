给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

 

示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
示例 2：

输入：nums = [0,1]
输出：[[0,1],[1,0]]
示例 3：

输入：nums = [1]
输出：[[1]]
 

提示：

1 <= nums.length <= 6
-10 <= nums[i] <= 10
nums 中的所有整数 互不相同



class Solution {
    public List<List<Integer>> permute(int[] nums) {
        int len = nums.length;
        LinkedList<List<Integer>> ans = new LinkedList<>();

        LinkedList<Integer> arr = new LinkedList<>();
        LinkedList<Integer> index = new LinkedList<>();
        boolean []used = new boolean[len];
        
        // 初始化插入
        arr.add(nums[0]);
        index.add(0);
        used[0] = true;
        while(true) {
            // 按顺序插满list
            for(int i = 0; i < len; i++) {
                if (!used[i]) {
                    arr.addLast(nums[i]);
                    index.addLast(i);
                    used[i] = true;
                }
            }

            // 输出结果
            ans.add(new LinkedList<>(arr));

            // 回溯判断，需要插入下一个base
            while(true) {
                int i = index.peekLast() + 1;
                for(; i < len; i++) {
                    if (!used[i]) {
                        // 插入base
                        // break
                        used[index.peekLast()] = false;
                        arr.pollLast();
                        index.pollLast();

                        arr.addLast(nums[i]);
                        index.addLast(i);
                        used[i] = true;

                        break;
                    }
                }
                
                // 如果没插入，弹栈

                // 如果插入了 break
                if (i == len) {
                    used[index.peekLast()] = false;
                    arr.pollLast();
                    index.pollLast();

                    // 如果list空了说明所有结果遍历完成
                    if (arr.isEmpty()) return ans;
                } else {
                    break;
                }
            }
        }

    }
}