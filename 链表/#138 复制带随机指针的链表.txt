给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。

要求返回这个链表的 深拷贝。 

我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：

val：一个表示 Node.val 的整数。
random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。
 

示例 1：



输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
示例 2：



输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
示例 3：



输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
示例 4：

输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。

/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }
        Node curr = head;
        Node copyCurr = null;
        Node copyPre = null;
        Node copyHead = null;
        Node temp = null;
        // 第一层循环深拷贝，只拷贝next引用。同时原链表的next引用指向一个临时节点，临时节点的next引用指向该节点的原next引用，random
        // 引用指向深拷贝的该节点，临时节点将原节点和拷贝节点联系起来
        while (curr != null) {
            copyCurr = new Node(curr.val);
            if (copyPre != null) {
                copyPre.next = copyCurr;
            }
            if (copyHead == null) {
                copyHead = copyCurr;
            }
            copyPre = copyCurr;

            temp = new Node(0);
            temp.next = curr.next;
            temp.random = copyPre;
            curr.next = temp;
            curr = temp.next;
            temp = null;
        }
        // 第二层循环利用临时节点获取random引用对应的新拷贝节点
        copyCurr = copyHead;
        curr = head;
        while (copyCurr != null) {
            if (curr.random != null) {
                copyCurr.random = curr.random.next.random;
            } else {
                copyCurr.random = null;
            }
            copyCurr = copyCurr.next;
            curr = curr.next.next;
        }
        // 第三层循环恢复原始节点的next引用
        curr = head;
        while (curr != null) {
            curr.next = curr.next.next;
            curr = curr.next;
        }

        return copyHead;


    }
}